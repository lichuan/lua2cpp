/*
 author: lichuan
 qq: 308831759
 email: 308831759@qq.com
 homepage: www.lichuan.me
 github: https://github.com/lichuan/lua2cpp
 date: 2013-05-11
 desc: this is the binding code between lua and c++ generated by lua2cpp.rb
*/

static void get_global_table(lua_State *lua_state, const char *nodes_name)
{
    char buf[1024];
    strcpy(buf, nodes_name);
    char *p = buf;
    const char *q = p;
    int count = 0;

    while(*p != 0)
    {
        if(*p == '.')
        {
            *p = 0;

            if(count == 0)
            {
                lua_getglobal(lua_state, q);

                if(lua_isnil(lua_state, -1))
                {
                    return;
                }
            }
            else
            {
                lua_pushstring(lua_state, q);
                lua_rawget(lua_state, -2);

                if(lua_isnil(lua_state, -1))
                {
                    return;
                }
            }

            q = p + 1;
            ++count;
        }

        ++p;
    }
    
    if(count == 0)
    {
        lua_getglobal(lua_state, q);

        if(lua_isnil(lua_state, -1))
        {
            return;
        }
    }
    else
    {
        lua_pushstring(lua_state, q);
        lua_rawget(lua_state, -2);

        if(lua_isnil(lua_state, -1))
        {
            return;
        }
    }
}

static void build_global_table(lua_State *lua_state, const char *nodes_name)
{
    char buf[1024];
    strcpy(buf, nodes_name);
    char *p = buf;
    const char *q = p;
    int count = 0;

    while(*p != 0)
    {
        if(*p == '.')
        {
            *p = 0;

            if(count == 0)
            {
                lua_getglobal(lua_state, q);

                if(lua_isnil(lua_state, -1))
                {
                    lua_newtable(lua_state);
                    lua_pushvalue(lua_state, -1);
                    lua_setglobal(lua_state, q);
                }
            }
            else
            {
                lua_pushstring(lua_state, q);
                lua_rawget(lua_state, -2);

                if(lua_isnil(lua_state, -1))
                {
                    lua_pop(lua_state,  1);
                    lua_pushstring(lua_state, q);
                    lua_newtable(lua_state);
                    lua_pushvalue(lua_state, -1);
                    lua_insert(lua_state, -4);
                    lua_rawset(lua_state, -3);
                    lua_pop(lua_state, 1);
                }
            }

            q = p + 1;
            ++count;
        }

        ++p;
    }
    
    if(count == 0)
    {
        lua_getglobal(lua_state, q);

        if(lua_isnil(lua_state, -1))
        {
            lua_newtable(lua_state);
            lua_setglobal(lua_state, q);
        }
    }
    else
    {
        lua_pushstring(lua_state, q);
        lua_rawget(lua_state, -2);

        if(lua_isnil(lua_state, -1))
        {
            lua_pop(lua_state,  1);
            lua_pushstring(lua_state, q);
            lua_newtable(lua_state);
            lua_rawset(lua_state, -3);
        }
    }

    lua_settop(lua_state, 0);
}

static int lua____dat_ns___Data__new(lua_State *lua_state)
{
    lua_settop(lua_state, 0);
    uint32 *udata = (uint32*)lua_newuserdata(lua_state, sizeof(uint32) + sizeof(dat_ns::Data*));
    uint32 &gc_flag = *udata;
    gc_flag = 1; /* need gc default in constructor */
    udata += 1;
    *(dat_ns::Data**)udata = new dat_ns::Data();
    luaL_setmetatable(lua_state, "_dat_ns.Data");

    return 1;
}

static int lua____dat_ns___Data__id(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "_dat_ns.Data");
    udata_self += 1;
    dat_ns::Data *obj = *(dat_ns::Data**)udata_self;
    uint32 v = obj->id;
    lua_pushunsigned(lua_state, v);

    return 1;
}

static int lua____dat_ns___Data__set_id(lua_State *lua_state)
{
    uint32 *udata = (uint32*)luaL_checkudata(lua_state, 1, "_dat_ns.Data");
    udata += 1;
    dat_ns::Data *obj = *(dat_ns::Data**)udata;
    uint32 arg_1 = luaL_checkunsigned(lua_state, 2);
    lua_settop(lua_state, 0);
    obj->id = arg_1;

    return 0;
}

static int lua____dat_ns___Data__name(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "_dat_ns.Data");
    udata_self += 1;
    dat_ns::Data *obj = *(dat_ns::Data**)udata_self;
    std::string v = obj->name;
    lua_pushstring(lua_state, v.c_str());

    return 1;
}

static int lua____dat_ns___Data__set_name(lua_State *lua_state)
{
    uint32 *udata = (uint32*)luaL_checkudata(lua_state, 1, "_dat_ns.Data");
    udata += 1;
    dat_ns::Data *obj = *(dat_ns::Data**)udata;
    const char *arg_1 = luaL_checkstring(lua_state, 2);
    lua_settop(lua_state, 0);
    obj->name = arg_1;

    return 0;
}

static int lua____dat_ns___Data__garbage_colloect(lua_State *lua_state)
{
    uint32 *udata = (uint32*)luaL_checkudata(lua_state, 1, "_dat_ns.Data");
    uint32 &gc_flag = *udata;
 
    if(gc_flag == 1)
    {
        udata += 1;
        dat_ns::Data *obj = *(dat_ns::Data**)udata;
        delete obj;
    }

    return 0;
}

static int lua___Test_Lua__new(lua_State *lua_state)
{
    lua_settop(lua_state, 0);
    uint32 *udata = (uint32*)lua_newuserdata(lua_state, sizeof(uint32) + sizeof(Test_Lua*));
    uint32 &gc_flag = *udata;
    gc_flag = 1; /* need gc default in constructor */
    udata += 1;
    *(Test_Lua**)udata = new Test_Lua();
    luaL_setmetatable(lua_state, "Test_Lua");

    return 1;
}

static int lua___Test_Lua__get_data(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    udata_self += 1;
    Test_Lua *obj = *(Test_Lua**)udata_self;
    lua_settop(lua_state, 0);
    dat_ns::Data *v = new dat_ns::Data;
    *v = obj->get_data();
    uint32 *udata = (uint32*)lua_newuserdata(lua_state, sizeof(uint32) + sizeof(dat_ns::Data*));
    uint32 &gc_flag = *udata;
    gc_flag = 1; /* no ptr, no ref, it's a new obj, so it need gc */
    udata += 1;
    *(dat_ns::Data**)udata = v;
    luaL_setmetatable(lua_state, "_dat_ns.Data");

    return 1;
}

static int lua___Test_Lua__get_ref_data(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    udata_self += 1;
    Test_Lua *obj = *(Test_Lua**)udata_self;
    lua_settop(lua_state, 0);
    const dat_ns::Data *v = &obj->get_ref_data();
    uint32 *udata = (uint32*)lua_newuserdata(lua_state, sizeof(uint32) + sizeof(dat_ns::Data*));
    uint32 &gc_flag = *udata;
    gc_flag = 0;
    udata += 1;
    *(dat_ns::Data**)udata = (dat_ns::Data*)v;
    luaL_setmetatable(lua_state, "_dat_ns.Data");

    return 1;
}

static int lua___Test_Lua__set_data_id(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    udata_self += 1;
    Test_Lua *obj = *(Test_Lua**)udata_self;
    uint32 arg_1 = luaL_checkunsigned(lua_state, 2);
    lua_settop(lua_state, 0);
    obj->set_data_id(arg_1);

    return 0;
}

static int lua___Test_Lua__set_data_name(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    udata_self += 1;
    Test_Lua *obj = *(Test_Lua**)udata_self;
    const char *arg_1 = luaL_checkstring(lua_state, 2);
    lua_settop(lua_state, 0);
    obj->set_data_name(arg_1);

    return 0;
}

static int lua___Test_Lua__get_data_name(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    udata_self += 1;
    Test_Lua *obj = *(Test_Lua**)udata_self;
    lua_settop(lua_state, 0);
    std::string v = obj->get_data_name();
    lua_pushstring(lua_state, v.c_str());

    return 1;
}

static int lua___Test_Lua__get_data_id(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    udata_self += 1;
    Test_Lua *obj = *(Test_Lua**)udata_self;
    lua_settop(lua_state, 0);
    uint32 v = obj->get_data_id();
    lua_pushunsigned(lua_state, v);

    return 1;
}

static int lua___Test_Lua__replace_data(lua_State *lua_state)
{
    uint32 *udata_self = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    udata_self += 1;
    Test_Lua *obj = *(Test_Lua**)udata_self;
    uint32 *udata_1 = (uint32*)luaL_checkudata(lua_state, 2, "_dat_ns.Data");
    udata_1 += 1;
    dat_ns::Data *arg_1 = *(dat_ns::Data**)udata_1;
    lua_settop(lua_state, 0);
    obj->replace_data(*arg_1);

    return 0;
}

static int lua___Test_Lua__garbage_colloect(lua_State *lua_state)
{
    uint32 *udata = (uint32*)luaL_checkudata(lua_state, 1, "Test_Lua");
    uint32 &gc_flag = *udata;
 
    if(gc_flag == 1)
    {
        udata += 1;
        Test_Lua *obj = *(Test_Lua**)udata;
        delete obj;
    }

    return 0;
}

static void register_lua(lua_State *lua_state)
{
    /* register non-global namespace */
    lua_settop(lua_state, 0);
    build_global_table(lua_state, "_dat_ns.Data");
    get_global_table(lua_state, "_dat_ns.Data");
    luaL_newmetatable(lua_state, "_dat_ns.Data");
    lua_pushvalue(lua_state, -2);
    lua_setfield(lua_state, -2, "__index");

    lua_settop(lua_state, 0);
    build_global_table(lua_state, "Test_Lua");
    get_global_table(lua_state, "Test_Lua");
    luaL_newmetatable(lua_state, "Test_Lua");
    lua_pushvalue(lua_state, -2);
    lua_setfield(lua_state, -2, "__index");

    {
        luaL_Reg _dat_ns_Data[] = 
        {
            {"new", lua____dat_ns___Data__new},
            {"id", lua____dat_ns___Data__id},
            {"set_id", lua____dat_ns___Data__set_id},
            {"name", lua____dat_ns___Data__name},
            {"set_name", lua____dat_ns___Data__set_name},
            {"__gc", lua____dat_ns___Data__garbage_colloect},
            {NULL, NULL}
        };

        lua_settop(lua_state, 0);
        get_global_table(lua_state, "_dat_ns.Data");
        luaL_setfuncs(lua_state, _dat_ns_Data, 0);
    }

    {
        luaL_Reg Test_Lua[] = 
        {
            {"new", lua___Test_Lua__new},
            {"get_data", lua___Test_Lua__get_data},
            {"get_ref_data", lua___Test_Lua__get_ref_data},
            {"set_data_id", lua___Test_Lua__set_data_id},
            {"set_data_name", lua___Test_Lua__set_data_name},
            {"get_data_name", lua___Test_Lua__get_data_name},
            {"get_data_id", lua___Test_Lua__get_data_id},
            {"replace_data", lua___Test_Lua__replace_data},
            {"__gc", lua___Test_Lua__garbage_colloect},
            {NULL, NULL}
        };

        lua_settop(lua_state, 0);
        get_global_table(lua_state, "Test_Lua");
        luaL_setfuncs(lua_state, Test_Lua, 0);
    }
}
